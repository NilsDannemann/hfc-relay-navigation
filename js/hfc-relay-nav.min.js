'use strict';

/**
 * class HFCRelayNav
 */

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var HFCRelayNav = function () {
  function HFCRelayNav() {
    _classCallCheck(this, HFCRelayNav);

    this.options = {
      initCallback: function initCallback() {},
      vpHeight: false,
      vpWidth: false,
      backLinkText: 'Zurück'
    };
  }
  /**
   * Options
   */

  _createClass(HFCRelayNav, [{
    key: 'init',

    /**
     * Initilatization
     * @param {String} Selector | Element
     * @param {Object} Options
     */
    value: function init(sel, options) {
      var root = this;
      var selector = document.querySelector(sel);

      /**
       * Settings options
       */
      root._setViewport(); // assigning viewport options

      /**
       * Merging options from the initialization
       */
      root.options = Object.assign(root.options, options);

      /**
       * Changing the viewport options on resize
       */
      window.addEventListener('resize', function () {
        root._setViewport();
      }, true);

      /**
       * Add submenu classes
       */
      this._applySubmenuToElement(selector, 'has-submenu');

      /**
       * Toggle dropdown
       */
      var submenu = selector.querySelectorAll('.has-submenu');
      root._map(submenu, function (item) {
        item.querySelector('a:not(.back)').addEventListener('click', function (event) {
          var parent = event.target.parentNode;
          var classNames = ['show'];
          var right = parseInt(item.getElementsByTagName('ul')[0].getBoundingClientRect().right);

          /**
           * Pushing menu to the left side when its outside the viewport
           */
          if (right >= root.options.vpWidth) {
            classNames.push('from-left');
          }

          /**
           * Toggleing some classes
           */
          root._toggleClass(parent, 'is-open');
          root._toggleClass(parent.querySelector('ul'), classNames);
        });
      });

      /*
       * Remove when clicked outside dropdown
       */
      document.addEventListener('click', function (event) {
        var openedDropdowns = selector.querySelectorAll('ul.show');

        if (!root._getClosest(event.target, '.has-submenu') && !root._getClosest(event.target, '.priority-nav-is-visible') && event.target !== event.target.querySelector('.has-submenu') && !event.target.classList.contains('back')) {
          /**
           * Close all opened dropdowns when clicking outside nav
           */
          root._map(openedDropdowns, function (openedDropdown) {
            root._toggleClass(openedDropdown, 'show');
            root._toggleClass(openedDropdown.parentNode, 'is-open');
          });
        } else if (root._getClosest(event.target, '.priority-nav-is-visible')) {
          /**
           * Special behaivior for mobile nav trigger
           */
          var openedLis = selector.querySelectorAll('li.is-open');
          root._map(openedLis, function (openedLi) {
            root._toggleClass(openedLi.querySelector('ul.show'), 'show');
            root._toggleClass(openedLi, 'is-open');
          });
        } else if (!event.target.classList.contains('back')) {
          root._map(openedDropdowns, function (openedDropdown) {
            var nearestLi = root._getClosest(event.target.parentNode, '.is-open');

            /**
             * Close all other opened dropdowns when opened a new
             */
            if (openedDropdown.parentNode !== nearestLi && !openedDropdown.parentNode.contains(nearestLi)) {
              root._toggleClass(openedDropdown, 'show');
              root._toggleClass(openedDropdown.parentNode, 'is-open');
            }
          });
        }
      });

      /**
       * Add eventlistener to back button to hide the submenu
       */
      var backLinks = selector.querySelectorAll('a.back');

      /**
       * Looping all links and add a eventlistener to it
       */
      root._map(backLinks, function (backLink) {
        backLink.addEventListener('click', function (event) {
          var ul = backLink.parentNode.parentNode;

          if (ul.classList.contains('show')) {
            root._toggleClass(ul, 'show');

            if (ul.parentNode.classList.contains('has-submenu')) {
              root._toggleClass(ul.parentNode, 'is-open');
            }
          }
        });
      });

      /**
       * Running the callback after initializing
       */
      root.options.initCallback();
    }
  }, {
    key: '_toggleClass',

    /**
     * Toggle class on element
     * @param {String} el
     * @param {String|Array} classNames
     */
    value: function _toggleClass(el, classNames) {
      var root = this;
      var classes = el && el.className ? el.className.split(' ') : [];
      var action = classes.indexOf('show') !== -1 ? 'hide' : 'show';
      var type = typeof classNames === 'undefined' ? 'undefined' : _typeof(classNames);

      /**
       * Checking if the classNames are a string or object
       */
      if (type === 'string') {
        el.classList.toggle(classNames);
      } else if (type === 'object') {
        var existingIndex = classes.indexOf('from-left');

        /**
         * Removeing classes
         */
        classNames.map(function (className) {
          el.classList.toggle(className);
        });

        /**
         * Little delay for smooth transitions
         */
        if (existingIndex === 1) {
          setTimeout(function () {
            el.classList.toggle('from-left');
          }, 350);
        }

        /**
         * Hide all children that are visible
         */
        if (action == 'hide') {
          root._map(el.querySelectorAll('ul.show'), function (ul) {
            root._toggleClass(ul, 'show');
          });
        }
      }
    }
  }, {
    key: '_setViewport',

    /**
     * Returns the viewport width and height
     */
    value: function _setViewport() {
      var root = this;

      /**
       * Setting some options for viewport calculations
       */
      ['Width', 'Height'].map(function (name) {
        var docVal = document.documentElement['client' + name];
        var winVal = window['inner' + name];
        var number = Math.min(docVal, winVal);

        eval('root.options.vp' + name + ' = ' + number);
      });
    }
  }, {
    key: '_getClosest',

    /**
     * Get the closest matching element up the DOM tree
     * @param {Element} elem Starting element
     * @param {String} selector Selector to match against (class, ID, or data attribute)
     * @return {Boolean|Element} Returns false if not match found
     */
    value: function _getClosest(elem, selector) {
      var firstChar = selector.charAt(0);

      for (; elem && elem !== document; elem = elem.parentNode) {
        if (firstChar === '.') {
          if (elem.classList.contains(selector.substr(1))) {
            return elem;
          }
        } else if (firstChar === '#') {
          if (elem.id === selector.substr(1)) {
            return elem;
          }
        } else if (firstChar === '[') {
          if (elem.hasAttribute(selector.substr(1, selector.length - 2))) {
            return elem;
          }
        }
      }

      return false;
    }
  }, {
    key: '_applySubmenuToElement',

    /**
     * Apllys a class to a Element recursively
     * @param {String} selector Selector to match against (class, ID, or data attribute)
     * @param {String} class name to add
     */
    value: function _applySubmenuToElement(selector, className) {
      var root = this;

      /**
       * Looping all lis
       */
      root._map(selector.querySelectorAll('li'), function (li) {
        /**
         * Check if the li has children and add has-submenu to it
         */
        if (li.childNodes.length > 1) {
          /**
           * Creating some DOM-Elements to store the back link
           */
          var backLink = document.createElement('li');
          var aTag = document.createElement('a');

          /**
           * Appending elements to the li to display the back link
           */
          aTag.appendChild(document.createTextNode(root.options.backLinkText));
          aTag.classList = 'back';
          backLink.appendChild(aTag);

          /**
           * Appending the li to the ul at the first position
           */
          var ul = li.querySelector('ul');
          ul.insertBefore(backLink, ul.firstChild);

          /**
           * Adding has-submenu to the li
           */
          root._toggleClass(li, className);
        }
      });
    }
  }, {
    key: '_map',

    /**
     * Wrapper for [1,2,3].map
     * @param {Array} Array
     * @param {Func} function to call
     */
    value: function _map(array, func) {
      return Array.prototype.map.call(array, func);
    }
  }]);

  return HFCRelayNav;
}();